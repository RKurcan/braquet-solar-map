<script src="//maps.googleapis.com/maps/api/js?libraries=drawing,places" type="text/javascript">
</script>

<style type="text/css">
      #{{gmap.identifier}} { {{gmap.style}} }
</style>

<script type="text/javascript">
    function getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, callback) {
        $.ajax({
            type : "POST",
            url  : "/nrel",
            data : JSON.stringify({"lat"      : latlngCenter.lat(),
                                   "lng"      : latlngCenter.lng(),
                                   "tilt"     : tiltValue, 
                                   "azimuth"  : azimuthValue,
                                   "capacity" : systemCapacity}, 
                                   null, '\t'),
            contentType: 'application/json; charset=UTF-8',
            success: function (result) {
                callback(result);
            }
        })
    }

    function CenterControl(controlDiv, map) {
         // Set CSS for the control border.
        var controlUI = document.createElement('div');
        controlUI.id = 'control'
        controlUI.className = 'form-inline'

        controlUI.style.backgroundColor = '#fff';
        controlUI.style.border = '2px solid #fff';
        controlUI.style.borderRadius = '3px';
        controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
        controlUI.style.marginBottom = '22px';
        controlUI.style.padding = '22px';
        controlUI.style.textAlign = 'left';
        controlDiv.appendChild(controlUI);
        // Set CSS for the control interior.
        var controlText = document.createElement('div');
        controlText.id = 'settings'
        controlText.style.color = 'rgb(25,25,25)';
        controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
        controlText.style.fontSize = '13px';
        controlText.style.lineHeight = '15px';
        controlText.style.paddingLeft = '5px';
        controlText.style.paddingRight = '5px';
        controlText.innerHTML = '<h4>Project Settings</h4>';
        controlText.innerHTML += '<div id="projectStats" style="font-size:12px;"></div>';
        controlText.innerHTML += '<div id="systemMatrix" style="font-size:12px;"></div>';
        
        controlText.innerHTML += '<input class="form-control" id ="azimuth" type="text" placeholder="Azimuth (Deg)">';            
        controlText.innerHTML += '<input class="form-control" id ="tilt" type="text" placeholder="Tilt (Deg)">';
        controlText.innerHTML += '<input class="form-control" id ="rowSpace" type="text" placeholder="Row space (in.)">';
        controlText.innerHTML += '<select class="form-control" id="orientation"><option value="portrait" selected>Portrait</option><option value="landscape">Landscape</option></select>';
        controlText.innerHTML += '<br><br><div id="submit"><button class="btn btn-default" id="update">Update</button></div>';
        controlUI.appendChild(controlText);
    }

    function updateSystem() {
        // listener for update button click
        document.getElementById('update').onmousedown = function(){
            var selected_polygon = getSelectedPolygon();
            console.log("click status: " + selected_polygon.click_status);

            // check values are not null
            if (document.getElementById('azimuth').value != "")
                selected_polygon.azimuthValue = document.getElementById('azimuth').value;
            if (document.getElementById('tilt').value != "")
                selected_polygon.tiltValue = document.getElementById('tilt').value;
            if (document.getElementById('rowSpace').value != "")
                selected_polygon.rowSpaceValue = document.getElementById('rowSpace').value;
            if (document.getElementById('orientation').value != "")
                selected_polygon.orientationValue = document.getElementById('orientation').value;
            console.log(selected_polygon.azimuthValue);
            console.log(selected_polygon.tiltValue);
            console.log(selected_polygon.rowSpaceValue);
            console.log(selected_polygon.orientationValue);
            
            selected_polygon.pArray.setMap(null); 
            output = panelLayout(selected_polygon.polygon, 
                                 selected_polygon.coordinates, 
                                 Number(selected_polygon.azimuthValue), 
                                 selected_polygon.orientationValue, 
                                 selected_polygon.rowSpaceValue, 
                                 selected_polygon.tiltValue, 
                                 selected_polygon.moduleWattage);
            selected_polygon.systemCapacity = output["s"];
            selected_polygon.pArray = output["arr"];
            selected_polygon.latlngCenter = getPolygonCenter(selected_polygon.coordinates);
            getEnergyProduction(selected_polygon.latlngCenter, 
                        selected_polygon.tiltValue, selected_polygon.azimuthValue, 
                        selected_polygon.systemCapacity, function(data) {
                
                selected_polygon.energyProduction = data;
                // update table with system info
                var project_stats = document.getElementById("projectStats")
                project_stats.innerHTML = "Nameplate Capacity: " + selected_polygon.systemCapacity + "kW<br>";
                project_stats.innerHTML += "# of panels: " + selected_polygon.numPanels + "<br>";
                project_stats.innerHTML += "Energy Production: " + selected_polygon.energyProduction + "kWh (monthly)";
            });

            
        };
    }

    function selectPolygon(polygon_object) {
        unselectAllPolygons();
        polygon_object.click_status = 1;
        polygon_object.polygon.setOptions({fillColor: 'green',
                                           strokeColor: 'green'});

        var project_stats = document.getElementById("projectStats")
        project_stats.innerHTML = "Nameplate Capacity: " + polygon_object.systemCapacity + "kW<br>";
        project_stats.innerHTML += "# of panels: " + polygon_object.numPanels + "<br>";
        project_stats.innerHTML += "Energy Production: " + polygon_object.energyProduction + "kWh (monthly)";
    }

    function getSelectedPolygon() {
        for (i=0;i<polygons.length;i++) {
            if (polygons[i].click_status == 1)
                return polygons[i];
        }
    }

    function unselectAllPolygons() {
        for (i=0;i<polygons.length;i++) {
            if (polygons[i].click_status == 1) {
                polygons[i].click_status = 0;
                polygons[i].polygon.setOptions({fillColor: 'yellow',
                                                strokeColor: 'yellow'});
            }
        }
    }    
    
    function printCoordinates(coordinates) {
        for (var i=0; i < coordinates.length; i++) {
            var xy = coordinates[i];
            // requires lat()/lng() as lat/lng here are functions not keys in a dictionary
            console.log("lat: " + xy.lat() + "; lng: " + xy.lng());
        }
        console.log(coordinates[0].lat())
    }

    // determines max distance from all points so we can decide maximum number of panels that can be placed in one direction
    function maxDistance(roof_area) {
        var distance = [];
        for (var i = 0; i < roof_area.length; i++) {
            for (j = i + 1; j < roof_area.length; j++) {
                console.log(roof_area[i].lat-roof_area[j].lat)
                distance.push(Math.sqrt(Math.abs((Math.pow((roof_area[i].lng - roof_area[j].lng),2) + Math.pow((roof_area[i].lng - roof_area[j].lng),2)))));
                console.log('Distance: ' + Math.sqrt(Math.abs((Math.pow((roof_area[i].lng - roof_area[j].lng),2) + Math.pow((roof_area[i].lng - roof_area[j].lng),2)))))
            }
        }
        //console.log(distance)
        return Math.max(...distance);
    }

    function maxDistanceXY(roof_area) {
        var distance = [];
        for (var i = 0; i < roof_area.length; i++) {
            for (j = i + 1; j < roof_area.length; j++) {
                console.log(roof_area[i].y-roof_area[j].y)
                distance.push(Math.sqrt(Math.abs((Math.pow((roof_area[i].x - roof_area[j].x),2) + Math.pow((roof_area[i].x - roof_area[j].x),2)))));
                console.log('Distance: ' + Math.sqrt(Math.abs((Math.pow((roof_area[i].x - roof_area[j].x),2) + Math.pow((roof_area[i].x - roof_area[j].x),2)))))
            }
        }
        //console.log(distance)
        return Math.max(...distance);
    }

    function endCoords(roof_area) {
        var latRoof = [];
        var lngRoof = [];
        for (var i = 0; i < roof_area.length; i++) {
            // requires lat() as lat/lng here are functions 
            //not keys in a dictionary
            latRoof.push(roof_area[i].lat()); 
            lngRoof.push(roof_area[i].lng());
        }
        return [{
                 lat: Math.max(...latRoof),
                 lng: Math.max(...lngRoof)
        },      {
                 lat: Math.min(...latRoof),
                 lng: Math.min(...lngRoof)
        }]; // array of [max, min] coordinates
    }

    // check if a collection of points falls within a polygon
    function containsPolygon(points_array, polygon) {
        for (var i = 0; i < points_array.length; i++) {
            var point = new google.maps.LatLng(points_array[i].lat, points_array[i].lng);
            var roof_check = google.maps.geometry.poly.containsLocation(point, polygon);
            if (roof_check === false) {
                return false;
            }
        }
        return true;
    }

    function latLngToPoint(latLng) {
        var siny = Math.sin(latLng.lat * Math.PI / 180);

        // Truncating to 0.9999 effectively limits latitude to 89.189. This is
        // about a third of a tile past the edge of the world tile.
        siny = Math.min(Math.max(siny, -0.9999), 0.9999);

        return new google.maps.Point(
          TILE_SIZE * (0.5 + latLng.lng / 360),
          TILE_SIZE * (0.5 - Math.log((1 + siny) / (1 - siny)) / (4 * Math.PI)));
    }

    function pointToLatLng(xy){

        var newLng = 360 * (xy.x/TILE_SIZE - 0.5);

        var yConst = Math.pow(Math.E, -4*Math.PI*(xy.y/TILE_SIZE - 0.5));

        var newLat = (180/Math.PI) * Math.asin((yConst - 1)/(1 + yConst));

        var newCoord = {lat: newLat, lng: newLng};

        return newCoord;
    }


    function panelLayout(polygon, coordinates, azimuth, orientation, rowSpace, tilt, moduleWattage) {
        //azimuth - angle of panel from true North
        //tilt - angle of panel from ground - not working properly for portrait..might be the difference between latitude/longitude conversion from meters
        //rowSpace - space between rows 
        //orientation - 'landscape' or 'portrait'
        //moduleWattage - wattage of each panel

        TILE_SIZE = 256;

        latlngCenter = getPolygonCenter(coordinates);
        printCoordinates(coordinates);

        //tilt multiplier to adjust how the panel would look tilted
        var tilt_coeff = Math.cos(tilt*Math.PI/180);
        //solar spec before tilt is considered
        var pre_solar_spec = {width: 0.0000314, length: 0.0000214};

        if(orientation == 'portrait'){
            azimuth += 180; //not 0 bc it takes into account for the off-set so there are no negative values
            port = 1;
            lat = 0;
        } else if(orientation == 'landscape'){
            azimuth +=90
            port = 0;
            lat = 1;
        }

        console.log("azimuth " + azimuth)

        var tilt_coeff = Math.cos(tilt*Math.PI/180);

        var solar_spec = {width: Math.pow(tilt_coeff, lat) * pre_solar_spec.width, length:  Math.pow(tilt_coeff, port) * pre_solar_spec.length};

        var row_space = Math.pow(rowSpace, lat); // space between row of panels
        var col_space = Math.pow(rowSpace, port); // space between column of panels

        var radius = Math.sqrt(Math.pow(solar_spec.length / 2, 2) + Math.pow(solar_spec.width / 2, 2));
        
        // angle between center and a corner point of panel
        var angleSpread = Math.atan(solar_spec.width/(solar_spec.length))*2;
        
        //determines equivalent azimuth for angles over 180 as the layout algorithm only works in one direction    

        //Converts azimuth angle into opposing angle that's under 180 deg. and converts maximum geometry angle 
        if(azimuth >= 361 && azimuth <= 540){
            azimuth -= 360;
        }

        //the panel dimension changes effects the azimuth and this variable is the offsetter for both maxGeo and azimuth
        azimuthOffSet = (111.44889707494237 - angleSpread*180/Math.PI)/2

        azimuth -= azimuthOffSet;

        var real_azimuthAngle = azimuth/180*Math.PI + 55.1/180*Math.PI; //63 degrees is when the two squars line up

        thetaOffSet = -(8 + azimuthOffSet) * (Math.PI/180)

        if(azimuth >= 0 && azimuth <= 90 || azimuth >= 181 && azimuth <= 270) {
            azimuthAngle = -(real_azimuthAngle + Math.PI/2)
            var theta = (90 - azimuthAngle - thetaOffSet);

        } else if(azimuth >= 91 && azimuth <= 180 || azimuth >= 271 && azimuth <= 360){
            azimuthAngle = -(real_azimuthAngle + Math.PI/2)
            var theta = (90 - azimuthAngle - 90 * Math.PI/180 - thetaOffSet);
        }
        //Calculates maximum distance of rectangle outside that fits right ouside the polygon
        var maxArea = endCoords(coordinates);
        var dlat = Math.abs(maxArea[1].lat - maxArea[0].lat)
        var dlng = Math.abs(maxArea[1].lng - maxArea[0].lng)
        // initialize array for panel indexes
        var solarSystem = []; 
        var solarSystemXY = []; 
        //Angles to determine where central points of each panel will be in relation to the previous one
        var angle1 = (azimuthAngle + angleSpread + Math.PI)
        var angle2 = (azimuthAngle + Math.PI)
        //Geometric profile of the biggest possible recentangular area around the user selected polygon
        var maxGeo = [
            {lat: maxArea[1].lat + dlat*Math.cos(theta)*Math.cos(theta), lng: maxArea[1].lng + dlat*Math.sin(theta)*Math.cos(theta)},
            {lat: maxArea[1].lat + dlat - dlng*Math.sin(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng*Math.cos(theta)*Math.cos(theta)},
            {lat: maxArea[1].lat + dlat - dlat*Math.cos(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng - dlat*Math.sin(theta)*Math.cos(theta)},
            {lat: maxArea[1].lat + dlng*Math.sin(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng - dlng*Math.cos(theta)*Math.cos(theta)},
        ];

        var maxGeoXY =[]

        for(i=0; i<maxGeo.length; i++){
            maxGeoXY.push(latLngToPoint(maxGeo[i]))
        }
        

        //Determines the starting point of the panel layout depending on the azimuth
        if(azimuth >= 0 && azimuth <= 90){
            var initCorner = 0
        } else if(azimuth >= 91 && azimuth <= 180) {
            var initCorner = 1
        } else if(azimuth >= 181 && azimuth <= 270) {
            var initCorner = 2
        } else if(azimuth >= 271 && azimuth <= 360) {
            var initCorner = 3
        }
        // determines max number of rows/columns in a solar system
        var maxD2 = maxDistance(maxGeo);
        var maxD2XY = maxDistanceXY(maxGeoXY)
        var smallerDimPanel = Math.min(solar_spec.width, solar_spec.length)

        var num_col = Math.round(maxD2 / smallerDimPanel);
        var num_row = num_col;

        var num_colXY = Math.round(maxD2XY / smallerDimPanel);
        var num_rowXY = num_colXY;

        // lays out panel over the polygon and determines if it's in the polygon or not

        for (j = 0; j < num_colXY; j++) {
            for (i = 0; i < num_rowXY; i++) {
                var panelCoordsXY = [];
                var centerPanelCoordXY = {

                    x: maxGeoXY[initCorner].x + radius * Math.sin(angle2) * ((row_space*i - col_space*j)) + radius * Math.sin(angle1) * ((row_space*i + col_space*j)),
                    y: maxGeoXY[initCorner].y + radius * Math.cos(angle2) * (row_space*i - col_space*j) + radius * Math.cos(angle1) * (row_space*i + col_space*j)
                    
                };

                 // start populating rooftop from min lat, max lng ==> bottom right of panel
                var pv_corner_arrayXY = [
                {   // min lat, max lng ==> bottom right of panel
                    x: centerPanelCoordXY.x + radius * Math.sin(azimuthAngle),
                    y: centerPanelCoordXY.y + radius * Math.cos(azimuthAngle)
                    
                },
               {   // min lat, min lng ==> bottom left of panel
                    x: centerPanelCoordXY.x + radius * Math.sin(azimuthAngle + angleSpread),
                    y: centerPanelCoordXY.y + radius * Math.cos(azimuthAngle + angleSpread)
                    
                },
                {   // max lat, min lng top left of panel
                    x: centerPanelCoordXY.x + radius * Math.sin(azimuthAngle + Math.PI),
                    y: centerPanelCoordXY.y + radius * Math.cos(azimuthAngle + Math.PI)
                    
                },
                {   // max lat, max lng ==> top right of panel
                    x: centerPanelCoordXY.x + radius * Math.sin(azimuthAngle + angleSpread + Math.PI),
                    y: centerPanelCoordXY.y + radius * Math.cos(azimuthAngle + angleSpread + Math.PI)
                    
                }
                ];

                for(n=0; n<pv_corner_arrayXY.length; n++){
                    pv_corner_arrayXY[n] = pointToLatLng(pv_corner_arrayXY[n])
                }

                //check if any corners are not within our rooftop polygon
                if (containsPolygon(pv_corner_arrayXY, polygon) === false) {
                    continue;
                }
                //add panel to panel array
                
                for (m = 0; m < pv_corner_arrayXY.length; m++) {
                    panelCoordsXY.push(pv_corner_arrayXY[m]);
                }
                
                // add panel to solar system array
                solarSystemXY.push(panelCoordsXY);
            }
        }

        panelArray = new google.maps.Polygon({ 
            map: {{gmap.varname}},
            paths: solarSystemXY,
            strokeColor: 'grey',
            strokeOpacity: 1,
            strokeWeight: 1,
            fillColor: '#084c8d',
            fillOpacity: 1
        });

        var systemCapacity = moduleWattage * solarSystemXY.length/1000;
        var numPanels = solarSystemXY.length;

        //Creates shape of maximum panel area for testing. Comment out to layer max rectangle around clicked polygon
        // new google.maps.Polygon({ 
        //     map: map,
        //     paths: maxGeo,
        //     strokeColor: 'red',
        //     strokeOpacity: 1,
        //     strokeWeight: 1,
        //     fillColor: 'red',
        //     fillOpacity: 0.4
        // });

        return { p: polygon,
                 s: systemCapacity,
                 arr: panelArray,
                 numPanels: numPanels
               }
    }

    function getPolygonCenter(coordinates) {
        var bound = new google.maps.LatLngBounds();
        for (var i=0;i<coordinates.length; i++) {
            bound.extend( new google.maps.LatLng(coordinates[i].lat(), coordinates[i].lng()));
        }
        return bound.getCenter();
    }

    function Polygon(polygon) // polygon object
    {
        this.click_status = 0;

        this.polygon = polygon;
        this.coordinates = polygon.getPath().getArray();
        this.azimuthValue = 120;
        this.orientationValue = 'portrait';
        this.rowSpaceValue = 1.6;
        this.tiltValue = 30;
        this.moduleWattage = 235;
        this.systemCapacity = "loading...";
        this.latlngCenter = getPolygonCenter(this.coordinates); // updated in panelLayout()
        this.energyProduction = "loading...";
        this.pArray = null;
        this.numPanels = "loading...";
    }

    //***GLOBAL VARIABLES******
    var polygons = [];
    var {{gmap.varname}};

    function initialize_{{gmap.varname}}() {
        var markers = [];
        {{gmap.varname}} = new google.maps.Map(
        document.getElementById('{{gmap.identifier}}'), {
            center: new google.maps.LatLng({{gmap.center.0}}, {{gmap.center.1}}),
            zoom: {{gmap.zoom}},
            mapTypeId: google.maps.MapTypeId.{{gmap.maptype}}
        });
        // position search bar and enable autocomplete
        var search_input = document.getElementById('user_search');
        var autocomplete = new google.maps.places.Autocomplete(search_input);
        autocomplete.bindTo('bounds', {{gmap.varname}});
        //{{gmap.varname}}.controls[google.maps.ControlPosition.TOP_CENTER].push(search_input);
        // Get the full place details when the user selects a place from the
        // list of suggestions.
        var iw = new google.maps.InfoWindow();
        var m = new google.maps.Marker({
            map: {{gmap.varname}}
        });
        google.maps.event.addListener(m, 'click', function() {
            iw.open({{gmap.varname}}, m);
        });
        google.maps.event.addListener(autocomplete, 'place_changed', function() {
            iw.close();
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                return;
            }
            if (place.geometry.viewport) {
                {{gmap.varname}}.fitBounds(place.geometry.viewport);
            } else {
                {{gmap.varname}}.setCenter(place.geometry.location);
                {{gmap.varname}}.setZoom(17);
            }
        })
        // position center control manager
        var centerControlDiv = document.createElement('div');
        var centerControl = new CenterControl(centerControlDiv, map);
        centerControlDiv.index = 1;
        map.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(centerControlDiv);
        // drawing manager
        var draw = new google.maps.drawing.DrawingManager({
            drawingMode: null,
            drawingControl: true,
            drawingControlOptions: {
              position: google.maps.ControlPosition.TOP_RIGHT,
              drawingModes: [
                google.maps.drawing.OverlayType.POLYGON
              ]
            },
            polygonOptions: {
                fillColor: 'yellow',
                strokeColor: 'yellow',
                editable: true,
                draggable: false
            }
        });
        draw.setMap({{gmap.varname}});
        // event listener to obtain lat/lng coordinates from drawn polygon **************
        google.maps.event.addListener(draw, 'polygoncomplete', function (polygon) {
            // switch back to the hand option
            draw.setOptions({
                drawingMode: null
            });

            // create polygon object
            var p = new Polygon(polygon);
            polygons.push(p);
            // get array of vertices in lat/lng format of polygon
            var output = null;

            // select this polygon and unselect all others
            selectPolygon(p);

            // ***generate default panel layout independent of other listeners
            // requires lat() as lat/lng here are functions not keys in a dictionary
            output = panelLayout(polygon, p.coordinates, Number(p.azimuthValue), p.orientationValue, p.rowSpaceValue, p.tiltValue, p.moduleWattage);
            p.systemCapacity = output["s"];
            p.pArray = output["arr"];
            p.numPanels = output["numPanels"];
            getEnergyProduction(p.latlngCenter, p.tiltValue, p.azimuthValue, p.systemCapacity, function(data) {
                p.energyProduction = data;
                // update table with system info
                var project_stats = document.getElementById("projectStats")
                project_stats.innerHTML = "Nameplate Capacity: " + p.systemCapacity + "kW<br>";
                project_stats.innerHTML += "# of panels: " + p.numPanels + "<br>";
                project_stats.innerHTML += "Energy Production: " + p.energyProduction + "kWh (monthly)";

                // listener for click on polygon
                google.maps.event.addListener(p.polygon, 'click', function () {
                    // select this polygon and unselect all others
                    selectPolygon(p);
                });
                google.maps.event.addListener(p.pArray, 'click', function () {
                    // select this polygon and unselect all others
                    selectPolygon(p);
                });

            });

            // listen for edit event on moving existing vertices
            google.maps.event.addListener(p.polygon.getPath(), "set_at", function() {
                selectPolygon(p);
                p.coordinates = p.polygon.getPath().getArray();
                p.pArray.setMap(null); 
                output = panelLayout(p.polygon, p.coordinates, Number(p.azimuthValue), p.orientationValue, p.rowSpaceValue, p.tiltValue, p.moduleWattage);
                p.systemCapacity = output["s"];
                p.pArray = output["arr"];
                p.numPanels = output["numPanels"];
                p.latlngCenter = getPolygonCenter(p.coordinates);
                getEnergyProduction(p.latlngCenter, p.tiltValue, p.azimuthValue, p.systemCapacity, function(data) {
                    p.energyProduction = data;
                    selectPolygon(p);
                });
            })
            // listen for edit event on adding new vertices
            google.maps.event.addListener(p.polygon.getPath(), "insert_at", function() {
                selectPolygon(p);
                p.coordinates = p.polygon.getPath().getArray();
                p.pArray.setMap(null); 
                output = panelLayout(p.polygon, p.coordinates, Number(p.azimuthValue), p.orientationValue, p.rowSpaceValue, p.tiltValue, p.moduleWattage);
                p.systemCapacity = output["s"];
                p.pArray = output["arr"];
                p.numPanels = output["numPanels"];
                p.latlngCenter = getPolygonCenter(p.coordinates);
                getEnergyProduction(p.latlngCenter, p.tiltValue, p.azimuthValue, p.systemCapacity, function(data) {
                    p.energyProduction = data;
                    selectPolygon(p);
                });
            })
            // listen for undo edit event on polygon
            google.maps.event.addListener(p.polygon.getPath(), "remove_at", function() {
                selectPolygon(p);
                p.coordinates = p.polygon.getPath().getArray();
                p.pArray.setMap(null); 
                output = panelLayout(p.polygon, p.coordinates, Number(p.azimuthValue), p.orientationValue, p.rowSpaceValue, p.tiltValue, p.moduleWattage);
                p.systemCapacity = output["s"];
                p.pArray = output["arr"];
                p.numPanels = output["numPanels"];
                p.latlngCenter = getPolygonCenter(p.coordinates);
                getEnergyProduction(p.latlngCenter, p.tiltValue, p.azimuthValue, p.systemCapacity, function(data) {
                    p.energyProduction = data;
                    selectPolygon(p);
                });
            })

            // listen for mouseover polygon event
            google.maps.event.addListener(p.polygon, "mouseover", function() {
                p.polygon.setOptions({fillColor: "orange",
                                      strokeColor: "orange"});
            })

            google.maps.event.addListener(p.pArray, "mouseover", function() {
                p.polygon.setOptions({fillColor: "orange",
                                      strokeColor: "orange"});
            })

            // listen for mouse out polygon event
            google.maps.event.addListener(p.polygon, "mouseout", function() {
                if(p.click_status == 0) // unselected
                    p.polygon.setOptions({fillColor: "yellow",
                                      strokeColor: "yellow"});
                else // selected
                    p.polygon.setOptions({fillColor: "green",
                                      strokeColor: "green"});
            })

            // update array upon parameter changes in control box
            updateSystem();
        });
        
        {% for icon in gmap.markers %}
            {% for marker in gmap.markers[icon] %}
                var marker_{{loop.index0}} = new google.maps.Marker({
                    position: new google.maps.LatLng({{marker.0}}, {{marker.1}}),
                    map: {{gmap.varname}},
                    icon: "{{ icon }}"
                });
                // for view boundary fitting
                markers.push(marker_{{loop.index0}}); 
                {% if gmap.infobox != None %}
                        {% if gmap.typeflag %}
                            google.maps.event.addListener(marker_{{loop.index0}}, 'click',
                            getInfoCallback({{gmap.varname}}, "{{gmap.infobox[loop.index0]|safe}}"));
                        {% else %}
                            google.maps.event.addListener(marker_{{loop.index0}}, 'click',
                            getInfoCallback({{gmap.varname}}, "{{gmap.infobox|safe}}"));
                        {% endif %}
                {% endif %}
            {% endfor %}
        {% endfor %}
        {% for border in gmap.roof_borders %}
            var border_{{loop.index0}} = new google.maps.Polygon({
                paths: {{ border | safe }},
                strokeColor: 'yellow',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: 'yellow',
                fillOpacity: 0.35,
                editable: true
            });
            border_{{loop.index0}}.setMap({{gmap.varname}});
        {% endfor %}
        var bounds = new google.maps.LatLngBounds();
        for(i=0;i<markers.length;i++) {
            bounds.extend(markers[i].getPosition());
        }
        {{gmap.varname}}.fitBounds(bounds);
    }
    function getInfoCallback(map, content) {
        var infowindow = new google.maps.InfoWindow({content: content});
        return function() {
                infowindow.setContent(content);
                infowindow.open(map, this);
            };
    }
    google.maps.event.addDomListener(window, 'load', initialize_{{gmap.varname}});
</script>