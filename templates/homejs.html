<script src="//maps.googleapis.com/maps/api/js?libraries=drawing,places" type="text/javascript">
</script>

<style type="text/css">
      #{{gmap.identifier}} { {{gmap.style}} }
</style>

<script type="text/javascript">
    function getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, callback) {
        $.ajax({
            type : "POST",
            url  : "/nrel",
            data : JSON.stringify({"lat"      : latlngCenter.lat(),
                                   "lng"      : latlngCenter.lng(),
                                   "tilt"     : tiltValue, 
                                   "azimuth"  : azimuthValue,
                                   "capacity" : systemCapacity}, 
                                   null, '\t'),
            contentType: 'application/json; charset=UTF-8',
            success: function (result) {
                callback(result);
            }
        })
    }

    function CenterControl(controlDiv, map) {
             // Set CSS for the control border.
            var controlUI = document.createElement('div');
            controlUI.style.backgroundColor = '#fff';
            controlUI.style.border = '2px solid #fff';
            controlUI.style.borderRadius = '3px';
            controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
            controlUI.style.marginBottom = '22px';
            controlUI.style.padding = '22px';
            controlUI.style.textAlign = 'left';
            controlDiv.appendChild(controlUI);

            // Set CSS for the control interior.
            var controlText = document.createElement('div');
            controlText.id = 'settings'
            controlText.style.color = 'rgb(25,25,25)';
            controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
            controlText.style.fontSize = '13px';
            controlText.style.lineHeight = '15px';
            controlText.style.paddingLeft = '5px';
            controlText.style.paddingRight = '5px';

            controlText.innerHTML = 'Walmart Project Settings';
            controlText.innerHTML += '<div id="projectStats" style="font-size:12px;"></div>';
            controlText.innerHTML += '<div id="systemMatrix" style="font-size:12px;"></div>';
            
            controlText.innerHTML += '<br><br><div><span>Azimuth</span><input id = "azimuth" type="text" placeholder="Azimuth (Deg)"></div>';            
            controlText.innerHTML += '<br><br><div><span>Tilt</span><input id = "tilt" type="text" placeholder="Tilt (Deg)"></div>';
            controlText.innerHTML += '<br><br><div><span>Row Space</span><input id = "rowSpace" type="text" placeholder="Row space (in.)"></div>';
            controlText.innerHTML += '<br><br><div><span>Orientation</span><select id="orientation"><option value="portrait" selected>Portrait</option><option value="landscape">Landscape</option></select></div>';
             controlText.innerHTML += '<br><br><div id="submit"><button class="btn btn-default" id="update">Update</button></div>';

            controlUI.appendChild(controlText);
          }

    // function systemUpdate(){
    //     //var projectInfo = new panelLayout(polygon, coordinates,  30, 'landscape', 1.6, 30, 235);
    //     //projectInfo.systemArray.setMap(null);  
    //     alert('meow')
    // }
    
    function initialize_{{gmap.varname}}() {
        var markers = [];
        var {{gmap.varname}} = new google.maps.Map(
        document.getElementById('{{gmap.identifier}}'), {
            center: new google.maps.LatLng({{gmap.center.0}}, {{gmap.center.1}}),
            zoom: {{gmap.zoom}},
            mapTypeId: google.maps.MapTypeId.{{gmap.maptype}}
        });

        // position search bar and enable autocomplete
        var search_input = document.getElementById('user_search');
        var autocomplete = new google.maps.places.Autocomplete(search_input);
        autocomplete.bindTo('bounds', {{gmap.varname}});

        //{{gmap.varname}}.controls[google.maps.ControlPosition.TOP_CENTER].push(search_input);

        // Get the full place details when the user selects a place from the
        // list of suggestions.
        var iw = new google.maps.InfoWindow();
        var m = new google.maps.Marker({
            map: {{gmap.varname}}
        });
        google.maps.event.addListener(m, 'click', function() {
            iw.open({{gmap.varname}}, m);
        });

        google.maps.event.addListener(autocomplete, 'place_changed', function() {
            iw.close();
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                return;
            }
            if (place.geometry.viewport) {
                {{gmap.varname}}.fitBounds(place.geometry.viewport);
            } else {
                {{gmap.varname}}.setCenter(place.geometry.location);
                {{gmap.varname}}.setZoom(17);
            }
        })

        // position center control manager
        var centerControlDiv = document.createElement('div');
        var centerControl = new CenterControl(centerControlDiv, map);
        centerControlDiv.index = 1;
        map.controls[google.maps.ControlPosition.LEFT_TOP].push(centerControlDiv);
        // drawing manager
        var draw = new google.maps.drawing.DrawingManager({
            drawingMode: null,
            drawingControl: true,
            drawingControlOptions: {
              position: google.maps.ControlPosition.TOP_RIGHT,
              drawingModes: [
                google.maps.drawing.OverlayType.POLYGON
              ]
            },
            polygonOptions: {
                fillColor: 'yellow',
                strokeColor: 'yellow',
                editable: true,
                draggable: true
            }
        });
        draw.setMap({{gmap.varname}});

        // event listener to obtain lat/lng coordinates from drawn polygon **************
        google.maps.event.addListener(draw, 'polygoncomplete', function (polygon) {
            // switch back to the hand option
            draw.setOptions({
                drawingMode: null
            });

            // get array of vertices in lat/lng format of polygon
            var coordinates = polygon.getPath().getArray();

            var azimuthValue = 120;
            var orientationValue = 'portrait';
            var rowSpaceValue = 1.6;
            var tiltValue = 30;
            var moduleWattage = 235;
            var systemCapacity = 10;
            var latlngCenter = getPolygonCenter(coordinates); // updated in panelLayout()
            var energyProduction = 0;
            var pArray = null;
            var output = null;
            console.log("center points: " + latlngCenter.lat() + ", " + latlngCenter.lng());

            // ***generate default panel layout independent of other listeners
            // requires lat() as lat/lng here are functions not keys in a dictionary
            output = panelLayout(polygon, coordinates, Number(azimuthValue), orientationValue, rowSpaceValue, tiltValue, moduleWattage);
            systemCapacity = output["s"];
            pArray = output["arr"];
            getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, function(data) {
                energyProduction = data;
                // listener for click on polygon
                google.maps.event.addListener(polygon, 'click', function () {
                    alert("Energy Production " + energyProduction + " kWh");
                });
            });

            // listener for drag event
            google.maps.event.addListener(polygon, "dragend", function() {
                var new_coordinates = polygon.getPath().getArray();
                pArray.setMap(null); 
                output = panelLayout(polygon, new_coordinates, Number(azimuthValue), orientationValue, rowSpaceValue, tiltValue, moduleWattage);
                systemCapacity = output["s"];
                pArray = output["arr"];
                latlngCenter = getPolygonCenter(coordinates);
                getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, function(data) {
                    energyProduction = data;
                });
            })

            // listen for edit event on moving existing vertices
            google.maps.event.addListener(polygon.getPath(), "set_at", function() {
                var new_coordinates = polygon.getPath().getArray();
                pArray.setMap(null); 
                output = panelLayout(polygon, new_coordinates, Number(azimuthValue), orientationValue, rowSpaceValue, tiltValue, moduleWattage);
                systemCapacity = output["s"];
                pArray = output["arr"];
                latlngCenter = getPolygonCenter(coordinates);
                getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, function(data) {
                    energyProduction = data;
                });
            })

            // listen for edit event on adding new vertices
            google.maps.event.addListener(polygon.getPath(), "insert_at", function() {
                var new_coordinates = polygon.getPath().getArray();
                pArray.setMap(null); 
                output = panelLayout(polygon, new_coordinates, Number(azimuthValue), orientationValue, rowSpaceValue, tiltValue, moduleWattage);
                systemCapacity = output["s"];
                pArray = output["arr"];
                latlngCenter = getPolygonCenter(coordinates);
                getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, function(data) {
                    energyProduction = data;
                });
            })

            // listen for undo edit event on polygon
            google.maps.event.addListener(polygon.getPath(), "remove_at", function() {
                var new_coordinates = polygon.getPath().getArray();
                pArray.setMap(null); 
                output = panelLayout(polygon, new_coordinates, Number(azimuthValue), orientationValue, rowSpaceValue, tiltValue, moduleWattage);
                systemCapacity = output["s"];
                pArray = output["arr"];
                latlngCenter = getPolygonCenter(coordinates);
                getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, function(data) {
                    energyProduction = data;
                });
            })

            // listener for update button click
            document.getElementById('update').onmousedown = function(){
                // check values are not null
                if (document.getElementById('azimuth').value != "")
                    azimuthValue = document.getElementById('azimuth').value;
                if (document.getElementById('tilt').value != "")
                    tiltValue = document.getElementById('tilt').value;
                if (document.getElementById('rowSpace').value != "")
                    rowSpaceValue = document.getElementById('rowSpace').value;
                if (document.getElementById('orientation').value != "")
                    orientationValue = document.getElementById('orientation').value;
                console.log(azimuthValue);
                console.log(tiltValue);
                console.log(rowSpaceValue);
                console.log(orientationValue);
                
                pArray.setMap(null); 
                output = panelLayout(polygon, new_coordinates, Number(azimuthValue), orientationValue, rowSpaceValue, tiltValue, moduleWattage);
                systemCapacity = output["s"];
                pArray = output["arr"];
                latlngCenter = getPolygonCenter(coordinates);
                getEnergyProduction(latlngCenter, tiltValue, azimuthValue, systemCapacity, function(data) {
                    energyProduction = data;
                });
            };
        });

        function getPolygonCenter(coordinates) {
            var bound = new google.maps.LatLngBounds();
            for (var i=0;i<coordinates.length; i++) {
                bound.extend( new google.maps.LatLng(coordinates[i].lat(), coordinates[i].lng()));
            }
            return bound.getCenter();
        }

        function printCoordinates(coordinates) {
            for (var i=0; i < coordinates.length; i++) {
                var xy = coordinates[i];
                // requires lat()/lng() as lat/lng here are functions not keys in a dictionary
                console.log("lat: " + xy.lat() + "; lng: " + xy.lng());
            }
            console.log(coordinates[0].lat())
        }
        // determines max distance from all points so we can decide maximum number of panels that can be placed in one direction
        function maxDistance(roof_area) {
            var distance = [];
            for (var i = 0; i < roof_area.length; i++) {
                for (j = i + 1; j < roof_area.length; j++) {
                    console.log(roof_area[i].lat-roof_area[j].lat)
                    distance.push(Math.sqrt(Math.abs((Math.pow((roof_area[i].lng - roof_area[j].lng),2) + Math.pow((roof_area[i].lng - roof_area[j].lng),2)))));
                    console.log('Distance: ' + Math.sqrt(Math.abs((Math.pow((roof_area[i].lng - roof_area[j].lng),2) + Math.pow((roof_area[i].lng - roof_area[j].lng),2)))))
                }
            }
            //console.log(distance)
            return Math.max(...distance);
        }
        function endCoords(roof_area) {
            var latRoof = [];
            var lngRoof = [];
            for (var i = 0; i < roof_area.length; i++) {
                // requires lat() as lat/lng here are functions 
                //not keys in a dictionary
                latRoof.push(roof_area[i].lat()); 
                lngRoof.push(roof_area[i].lng());
            }
            return [{
                     lat: Math.max(...latRoof),
                     lng: Math.max(...lngRoof)
            },      {
                     lat: Math.min(...latRoof),
                     lng: Math.min(...lngRoof)
            }]; // array of [max, min] coordinates
        }
        // check if a collection of points falls within a polygon
        function containsPolygon(points_array, polygon) {
            for (var i = 0; i < points_array.length; i++) {
                var point = new google.maps.LatLng(points_array[i].lat, points_array[i].lng);
                var roof_check = google.maps.geometry.poly.containsLocation(point, polygon);
                if (roof_check === false) {
                    return false;
                }
            }
            return true;
        }



        function panelLayout(polygon, coordinates, azimuth, orientation, rowSpace, tilt, moduleWattage) {
            //azimuth - angle of panel from true North
            //tilt - angle of panel from ground - not working properly for portrait..might be the difference between latitude/longitude conversion from meters
            //rowSpace - space between rows 
            //orientation - 'landscape' or 'portrait'
            //moduleWattage - wattage of each panel

            printCoordinates(coordinates);
            //tilt multiplier to adjust how the panel would look tilted
            var tilt_coeff = Math.cos(tilt*Math.PI/180);
            //solar spec before tilt is considered
            var pre_solar_spec = {width: 0.0000214, length: 0.0000315};
            if(orientation == 'portrait'){
                azimuth += 90;
                port = 1;
                lat = 0;
            } else if(orientation == 'landscape'){
                azimuth = azimuth
                port = 0;
                lat = 1;
            }

            var solar_spec = {width: Math.pow(tilt_coeff, port) * pre_solar_spec.width, length: Math.pow(tilt_coeff, lat) * pre_solar_spec.length};
            console.log('Pre Tilt: ' + pre_solar_spec.width + 'Post: ' + solar_spec.width)
            var row_space = Math.pow(rowSpace, port); // space between row of panels
            var col_space = Math.pow(rowSpace, lat); // space between column of panels
            var radius = Math.sqrt(Math.pow(solar_spec.length / 2, 2) + Math.pow(solar_spec.width / 2, 2));
            // angle between center and a corner point of panel
            var angleSpread = Math.acos(solar_spec.width / (radius * 2));
            //determines equivalent azimuth for angles over 180 as the layout algorithm only works in one direction    
            var real_azimuthAngle = azimuth/180*Math.PI + 116.6/180*Math.PI ; //115 degrees is when the two squars line up
            //Converts azimuth angle into opposing angle that's under 180 deg. and converts maximum geometry angle 
            if(azimuth >= 0 && azimuth <= 90 || azimuth >= 181 && azimuth <= 270) {
                azimuthAngle = azimuth / 180 * Math.PI - 25 / 180 * Math.PI
                var theta = -(90 - azimuthAngle + 130 * Math.PI/180);
            } else if(azimuth >= 91 && azimuth <= 180 || azimuth >= 271 && azimuth <= 360){
                azimuthAngle = (azimuth -180) / 180 * Math.PI - 25 / 180 * Math.PI
                var theta = -(90 - azimuthAngle + 130 * Math.PI/180 - 90 * Math.PI/180);
            }
            //Calculates maximum distance of rectangle outside that fits right ouside the polygon
            var maxArea = endCoords(coordinates);
            var dlat = Math.abs(maxArea[1].lat - maxArea[0].lat)
            var dlng = Math.abs(maxArea[1].lng - maxArea[0].lng)
            // initialize array for panel indexes
            var solarSystem = []; 
            //Angles to determine where central points of each panel will be in relation to the previous one
            var angle1 = azimuthAngle + angleSpread + Math.PI
            var angle2 = azimuthAngle + Math.PI
            //Geometric profile of the biggest possible recentangular area around the user selected polygon
            var maxGeo = [
                {lat: maxArea[1].lat + dlat*Math.cos(theta)*Math.cos(theta), lng: maxArea[1].lng + dlat*Math.sin(theta)*Math.cos(theta)},
                {lat: maxArea[1].lat + dlat - dlng*Math.sin(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng*Math.cos(theta)*Math.cos(theta)},
                {lat: maxArea[1].lat + dlat - dlat*Math.cos(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng - dlat*Math.sin(theta)*Math.cos(theta)},
                {lat: maxArea[1].lat + dlng*Math.sin(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng - dlng*Math.cos(theta)*Math.cos(theta)},
            ];
            //Determines the starting point of the panel layout depending on the azimuth
            if(azimuth >= 0 && azimuth <= 90){
                var initCorner = 2
            } else if(azimuth >= 91 && azimuth <= 180) {
                var initCorner = 1
            } else if(azimuth >= 181 && azimuth <= 270) {
                var initCorner = 0
            } else if(azimuth >= 271 && azimuth <= 360) {
                var initCorner = 3
            }
            // determines max number of rows/columns in a solar system
            var maxD2 = maxDistance(maxGeo);
            var smallerDimPanel = Math.min(solar_spec.width, solar_spec.length)
            var num_col = Math.round(maxD2 / smallerDimPanel);
            var num_row = num_col;
            // lays out panel over the polygon and determines if it's in the polygon or not
            for (j = 0; j < num_col; j++) {
                for (i = 0; i < num_row; i++) {
                    var panelCoords = [];
                    var centerPanelCoord = {
                        lat: maxGeo[initCorner].lat + radius * Math.cos(angle2) * (row_space*i - col_space*j) + radius * Math.cos(angle1) * (row_space*i + col_space*j),
                        lng: maxGeo[initCorner].lng + radius * Math.sin(angle2) * (row_space*i - col_space*j) + radius * Math.sin(angle1) * (row_space*i + col_space*j)
                    };
                     // start populating rooftop from min lat, max lng ==> bottom right of panel
                    var pv_corner_array = [
                    {   // min lat, max lng ==> bottom right of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle)
                    },
                   {   // min lat, min lng ==> bottom left of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle + angleSpread),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle + angleSpread)
                    },
                    {   // max lat, min lng top left of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle + Math.PI),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle + Math.PI)
                    },
                    {   // max lat, max lng ==> top right of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle + angleSpread + Math.PI),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle + angleSpread + Math.PI)
                    }
                    ];
                    //check if any corners are not within our rooftop polygon
                    if (containsPolygon(pv_corner_array, polygon) === false) {
                        continue;
                    }
                    // add panel to panel array
                    for (m = 0; m < pv_corner_array.length; m++) {
                        panelCoords.push(pv_corner_array[m]);
                    }
                    
                    // add panel to solar system array
                    solarSystem.push(panelCoords);
                }
            }
            panelArray = new google.maps.Polygon({ 
                map: map,
                paths: solarSystem,
                strokeColor: 'grey',
                strokeOpacity: 1,
                strokeWeight: 1,
                fillColor: '#084c8d',
                fillOpacity: 1
            });

            var systemCapacity = moduleWattage * solarSystem.length/1000;
            var numPanels = solarSystem.length;

            var project_stats = document.getElementById("projectStats")
            project_stats.innerHTML = "Nameplate Capacity: " + systemCapacity + "kW<br>";
            project_stats.innerHTML += "# of panels: " + numPanels;

            //Creates shape of maximum panel area for testing. Comment out to layer max rectangle around clicked polygon
            // new google.maps.Polygon({ 
            //     map: map,
            //     paths: maxGeo,
            //     strokeColor: 'red',
            //     strokeOpacity: 1,
            //     strokeWeight: 1,
            //     fillColor: 'red',
            //     fillOpacity: 0.4
            // });

            return { p: polygon,
                     s: systemCapacity,
                     arr: panelArray,
            };
        }

        {% for icon in gmap.markers %}
            {% for marker in gmap.markers[icon] %}
                var marker_{{loop.index0}} = new google.maps.Marker({
                    position: new google.maps.LatLng({{marker.0}}, {{marker.1}}),
                    map: {{gmap.varname}},
                    icon: "{{ icon }}"
                });
                // for view boundary fitting
                markers.push(marker_{{loop.index0}}); 
                {% if gmap.infobox != None %}
                        {% if gmap.typeflag %}
                            google.maps.event.addListener(marker_{{loop.index0}}, 'click',
                            getInfoCallback({{gmap.varname}}, "{{gmap.infobox[loop.index0]|safe}}"));
                        {% else %}
                            google.maps.event.addListener(marker_{{loop.index0}}, 'click',
                            getInfoCallback({{gmap.varname}}, "{{gmap.infobox|safe}}"));
                        {% endif %}
                {% endif %}
            {% endfor %}
        {% endfor %}
        {% for border in gmap.roof_borders %}
            var border_{{loop.index0}} = new google.maps.Polygon({
                paths: {{ border | safe }},
                strokeColor: 'yellow',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: 'yellow',
                fillOpacity: 0.35,
                editable: true
            });
            border_{{loop.index0}}.setMap({{gmap.varname}});
        {% endfor %}
        var bounds = new google.maps.LatLngBounds();
        for(i=0;i<markers.length;i++) {
            bounds.extend(markers[i].getPosition());
        }
        {{gmap.varname}}.fitBounds(bounds);
    }



    function getInfoCallback(map, content) {
        var infowindow = new google.maps.InfoWindow({content: content});
        return function() {
                infowindow.setContent(content);
                infowindow.open(map, this);
            };
    }

    google.maps.event.addDomListener(window, 'load', initialize_{{gmap.varname}});
</script>