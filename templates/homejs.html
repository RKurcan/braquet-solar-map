<script src="//maps.googleapis.com/maps/api/js?sensor=false&libraries=drawing" type="text/javascript">
</script>

<style type="text/css">
      #{{gmap.identifier}} { {{gmap.style}} }
</style>

<script type="text/javascript">
    
    function initialize_{{gmap.varname}}() {
        var markers = [];
        var {{gmap.varname}} = new google.maps.Map(
        document.getElementById('{{gmap.identifier}}'), {
            center: new google.maps.LatLng({{gmap.center.0}}, {{gmap.center.1}}),
            zoom: {{gmap.zoom}},
            mapTypeId: google.maps.MapTypeId.{{gmap.maptype}}
        });

        // drawing manager
        var draw = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.POLYGON,
            drawingControl: true,
            drawingControlOptions: {
              position: google.maps.ControlPosition.TOP_CENTER,
              drawingModes: [
                google.maps.drawing.OverlayType.POLYGON
              ]
            },
            editable: true,
            draggable: true,
            polygonOptions: {
                fillColor: '#1E90FF',
                strokeColor: '#1E90FF'
            }
        });
        draw.setMap({{gmap.varname}});

        // event listener to obtain lat/lng coordinates from drawn polygon
        google.maps.event.addListener(draw, 'polygoncomplete', function (polygon) {
            var coordinates = polygon.getPath().getArray();

            // requires lat() as lat/lng here are functions not keys in a dictionary
            panelLayout(polygon, coordinates,  290);
        });



        function print_coordinates(coordinates) {
            for (var i=0; i < coordinates.length; i++) {
                var xy = coordinates[i];
                // requires lat()/lng() as lat/lng here are functions not keys in a dictionary
                console.log("lat: " + xy.lat() + "; lng: " + xy.lng());
            }
            console.log(coordinates[0].lat())
        }

        // determines max distance from all points so we can decide maximum number of panels that can be placed in one direction
        function maxDistance(roof_area) {
            var distance = [];

            for (var i = 0; i < roof_area.length; i++) {
                for (j = i + 1; j < roof_area.length; j++) {
                    console.log(roof_area[i].lat-roof_area[j].lat)
                    distance.push(Math.sqrt(Math.abs((Math.pow((roof_area[i].lng - roof_area[j].lng),2) + Math.pow((roof_area[i].lng - roof_area[j].lng),2)))));
                    console.log('Distance: ' + Math.sqrt(Math.abs((Math.pow((roof_area[i].lng - roof_area[j].lng),2) + Math.pow((roof_area[i].lng - roof_area[j].lng),2)))))
                }
            }
            //console.log(distance)
            return Math.max(...distance);
        }

        function endCoords(roof_area) {
            var latRoof = [];
            var lngRoof = [];
            for (var i = 0; i < roof_area.length; i++) {
                // requires lat() as lat/lng here are functions 
                //not keys in a dictionary
                latRoof.push(roof_area[i].lat()); 
                lngRoof.push(roof_area[i].lng());
            }

            return [{
                     lat: Math.max(...latRoof),
                     lng: Math.max(...lngRoof)
            },      {
                     lat: Math.min(...latRoof),
                     lng: Math.min(...lngRoof)
            }]; // array of [max, min] coordinates
        }

        // check if a collection of points falls within a polygon
        function containsPolygon(points_array, polygon) {
            for (var i = 0; i < points_array.length; i++) {
                var point = new google.maps.LatLng(points_array[i].lat, points_array[i].lng);
                var roof_check = google.maps.geometry.poly.containsLocation(point, polygon);
                if (roof_check === false) {
                    return false;
                }
            }
            return true;
        }

        // generate an array of solar panels and overlay them over a drawn rooftop/polygon
        function panelLayout(polygon, coordinates, azimuth) {
<<<<<<< HEAD
            print_coordinates(coordinates);

            var solar_spec = {width: 0.0000114, length: 0.0000115};
            var row_space = 1; // space between row of panels
            var col_space = 1; // space between column of panels

            var radius = Math.sqrt(Math.pow(solar_spec.length / 2, 2) + Math.pow(solar_spec.width / 2, 2));

            // angle between center and a corner point of panel
            var angleSpread = Math.acos(solar_spec.width / (radius * 2));
=======
            // 115 degrees is when the two squares line up
            var azimuthAngle = azimuth / 180 * Math.PI; 
>>>>>>> 3cead2f922553af28b9603341c6539ff7e1f71a1

            //determines equivalent azimuth for angles over 180 as the layout algorithm only works in one direction    
            var real_azimuthAngle = azimuth/180*Math.PI + 116.6/180*Math.PI ; //115 degrees is when the two squars line up

            //Converts azimuth angle into opposing angle that's under 180 deg. and converts maximum geometry angle 
            if(azimuth >= 0 && azimuth <= 90 || azimuth >= 181 && azimuth <= 270) {
                azimuthAngle = azimuth / 180 * Math.PI - 25 / 180 * Math.PI
                var theta = -(90 - azimuthAngle + 130 * Math.PI/180);

            } else if(azimuth >= 91 && azimuth <= 180 || azimuth >= 271 && azimuth <= 360){
                azimuthAngle = (azimuth -180) / 180 * Math.PI - 25 / 180 * Math.PI
                var theta = -(90 - azimuthAngle + 130 * Math.PI/180 - 90 * Math.PI/180);

            }

            //Calculates maximum distance of rectangle outside that fits right ouside the polygon
            var maxArea = endCoords(coordinates);
            var dlat = Math.abs(maxArea[1].lat - maxArea[0].lat)
            var dlng = Math.abs(maxArea[1].lng - maxArea[0].lng)

            // initialize array for panel indexes
            var solarSystem = []; 

            //Angles to determine where central points of each panel will be in relation to the previous one
            var angle1 = azimuthAngle + angleSpread + Math.PI
            var angle2 = azimuthAngle + Math.PI

            //Geometric profile of the biggest possible recentangular area around the user selected polygon
            var maxGeo = [

                {lat: maxArea[1].lat + dlat*Math.cos(theta)*Math.cos(theta), lng: maxArea[1].lng + dlat*Math.sin(theta)*Math.cos(theta)},
                {lat: maxArea[1].lat + dlat - dlng*Math.sin(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng*Math.cos(theta)*Math.cos(theta)},
                {lat: maxArea[1].lat + dlat - dlat*Math.cos(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng - dlat*Math.sin(theta)*Math.cos(theta)},
                {lat: maxArea[1].lat + dlng*Math.sin(theta)*Math.cos(theta), lng: maxArea[1].lng + dlng - dlng*Math.cos(theta)*Math.cos(theta)},

            ];

            //Determines the starting point of the panel layout depending on the azimuth
            if(azimuth >= 0 && azimuth <= 90){
                var initCorner = 2
            } else if(azimuth >= 91 && azimuth <= 180) {
                var initCorner = 1
            } else if(azimuth >= 181 && azimuth <= 270) {
                var initCorner = 0
            } else if(azimuth >= 271 && azimuth <= 360) {
                var initCorner = 3
            }

            // determines max number of rows/columns in a solar system
            var maxD2 = maxDistance(maxGeo);
            var num_col = Math.round(maxD2 / solar_spec.width) * 1;
            var num_row = num_col;

            // lays out panel over the polygon and determines if it's in the polygon or not
            for (j = 0; j < num_col; j++) {
                for (i = 0; i < num_row; i++) {
                    var panelCoords = [];
                    var centerPanelCoord = {

                        lat: maxGeo[initCorner].lat + radius * Math.cos(angle2) * (i-j) + radius * Math.cos(angle1) * (i+j),

                        lng: maxGeo[initCorner].lng + radius * Math.sin(angle2) * (i-j) + radius * Math.sin(angle1) * (i+j)

                    };


                     // start populating rooftop from min lat, max lng ==> bottom right of panel
                    var pv_corner_array = [
                    {   // min lat, max lng ==> bottom right of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle)
                    },
                   {   // min lat, min lng ==> bottom left of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle + angleSpread),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle + angleSpread)
                    },
                    {   // max lat, min lng top left of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle + Math.PI),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle + Math.PI)
                    },
                    {   // max lat, max lng ==> top right of panel
                        lat: centerPanelCoord.lat + radius * Math.cos(azimuthAngle + angleSpread + Math.PI),
                        lng: centerPanelCoord.lng + radius * Math.sin(azimuthAngle + angleSpread + Math.PI)
                    }
                    ];

                    //check if any corners are not within our rooftop polygon
                    if (containsPolygon(pv_corner_array, polygon) === false) {
                        continue;
                    }

                    // add panel to panel array
                    for (m = 0; m < pv_corner_array.length; m++) {
                        panelCoords.push(pv_corner_array[m]);
                    }
                    
                    // add panel to solar system array
                    solarSystem.push(panelCoords);
                }
            }
            new google.maps.Polygon({ 
                map: map,
                paths: solarSystem,
                strokeColor: 'grey',
                strokeOpacity: 1,
                strokeWeight: 1,
                fillColor: 'blue',
                fillOpacity: 1
            });

            //Creates shape of maximum panel area for testing. Comment out to layer max rectangle around clicked polygon
            // new google.maps.Polygon({ 
            //     map: map,
            //     paths: maxGeo,
            //     strokeColor: 'yellow',
            //     strokeOpacity: 1,
            //     strokeWeight: 1,
            //     fillColor: 'yellow',
            //     fillOpacity: 0.4
            // });
        }

        {% for icon in gmap.markers %}
            {% for marker in gmap.markers[icon] %}
                var marker_{{loop.index0}} = new google.maps.Marker({
                    position: new google.maps.LatLng({{marker.0}}, {{marker.1}}),
                    map: {{gmap.varname}},
                    icon: "{{ icon }}"
                });

                // for view boundary fitting
                markers.push(marker_{{loop.index0}}); 

                {% if gmap.infobox != None %}
                        {% if gmap.typeflag %}
                            google.maps.event.addListener(marker_{{loop.index0}}, 'click',
                            getInfoCallback({{gmap.varname}}, "{{gmap.infobox[loop.index0]|safe}}"));
                        {% else %}
                            google.maps.event.addListener(marker_{{loop.index0}}, 'click',
                            getInfoCallback({{gmap.varname}}, "{{gmap.infobox|safe}}"));
                        {% endif %}
                {% endif %}
            {% endfor %}
        {% endfor %}

        {% for border in gmap.roof_borders %}
            var border_{{loop.index0}} = new google.maps.Polygon({
                paths: {{ border | safe }},
                strokeColor: '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: '#FF0000',
                fillOpacity: 0.35,
                editable: true
            });
            border_{{loop.index0}}.setMap({{gmap.varname}});
        {% endfor %}

        var bounds = new google.maps.LatLngBounds();
        for(i=0;i<markers.length;i++) {
            bounds.extend(markers[i].getPosition());
        }

        {{gmap.varname}}.fitBounds(bounds);
    }



    function getInfoCallback(map, content) {
        var infowindow = new google.maps.InfoWindow({content: content});
        return function() {
                infowindow.setContent(content);
                infowindow.open(map, this);
            };
    }
    google.maps.event.addDomListener(window, 'load', initialize_{{gmap.varname}});
</script>